//
// Created by Kok on 7/2/25.
//

#include "ssd1306_i2c_driver.h"

#include <generic_methods.h>
#include <gpio_driver.h>
#include <string.h>
#include "commons.h"

static uint8_t sendBuffer[SSD1306_I2C_SEND_BUFFER_LEN];
static uint8_t frameBuffer[SSD1306_I2C_SEND_BUFFER_LEN - 1];            // Omitting the control byte

static SSD1306_Error_e send_commands(SSD1306_Handle_t *pSSD1306Handle, uint8_t *commands, uint32_t len);
static SSD1306_Error_e send_data(SSD1306_Handle_t *pSSD1306Handle, uint8_t *data, uint32_t len);

static void write_hor_font_over_16(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str);
static void write_hor_font_over_8(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str);
static void write_hor_font_8(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str);

static void h_addr_set_pixel(uint8_t x, uint8_t y, uint8_t on);
static void get_8x8_char_bitmap(SSD1306_Handle_t *pSSD1306Handle, char c, uint8_t *verticalChar);
static void *get_char_bitmap(SSD1306_Handle_t *pSSD1306Handle, char c);
static void convert_8x8_char_to_vertical(uint8_t *ch, uint8_t *verticalChar);
static void reset_state(SSD1306_Handle_t *pSSD1306Handle);

#define SSD1306_SEND_COMMANDS(handle, err, ...)         do {                                                        \
                                                            uint8_t cmds[] = {__VA_ARGS__};                         \
                                                            err = send_commands(handle, cmds, sizeof(cmds));        \
                                                        } while (0)

/* ------ FONTS ------ */

static uint8_t font8x8[96][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};

static uint8_t font8x16[96][16] = {
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x20, ' '
        { 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,  },       //0x21, '!'
        { 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x22, '"'
        { 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,  },       //0x23, '#'
        { 0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,  },       //0x24, '$'
        { 0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,  },       //0x25, '%'
        { 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,  },       //0x26, '&'
        { 0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x27, '''
        { 0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,  },       //0x28, '('
        { 0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,  },       //0x29, ')'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x2A, '*'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x2B, '+'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,  },       //0x2C, '
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x2D, '-'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,  },       //0x2E, '.'
        { 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,  },       //0x2F, '/'
        { 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xD6, 0xD6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,  },       //0x30, '0'
        { 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,  },       //0x31, '1'
        { 0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,  },       //0x32, '2'
        { 0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x33, '3'
        { 0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,  },       //0x34, '4'
        { 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x35, '5'
        { 0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x36, '6'
        { 0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,  },       //0x37, '7'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x38, '8'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,  },       //0x39, '9'
        { 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x3A, ':'
        { 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,  },       //0x3B, ';'
        { 0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,  },       //0x3C, '<'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x3D, '='
        { 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,  },       //0x3E, '>'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,  },       //0x3F, '?'
        { 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x40, '@'
        { 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x41, 'A'
        { 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,  },       //0x42, 'B'
        { 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x43, 'C'
        { 0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,  },       //0x44, 'D'
        { 0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,  },       //0x45, 'E'
        { 0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,  },       //0x46, 'F'
        { 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,  },       //0x47, 'G'
        { 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x48, 'H'
        { 0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x49, 'I'
        { 0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,  },       //0x4A, 'J'
        { 0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,  },       //0x4B, 'K'
        { 0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,  },       //0x4C, 'L'
        { 0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x4D, 'M'
        { 0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x4E, 'N'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x4F, 'O'
        { 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,  },       //0x50, 'P'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,  },       //0x51, 'Q'
        { 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,  },       //0x52, 'R'
        { 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x53, 'S'
        { 0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x54, 'T'
        { 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x55, 'U'
        { 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,  },       //0x56, 'V'
        { 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,  },       //0x57, 'W'
        { 0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x58, 'X'
        { 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x59, 'Y'
        { 0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,  },       //0x5A, 'Z'
        { 0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x5B, '['
        { 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,  },       //0x5C, '\'
        { 0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x5D, ']'
        { 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x5E, '^'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,  },       //0x5F, '_'
        { 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  },       //0x60, '`'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,  },       //0x61, 'a'
        { 0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x62, 'b'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x63, 'c'
        { 0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,  },       //0x64, 'd'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x65, 'e'
        { 0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,  },       //0x66, 'f'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,  },       //0x67, 'g'
        { 0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,  },       //0x68, 'h'
        { 0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x69, 'i'
        { 0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,  },       //0x6A, 'j'
        { 0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,  },       //0x6B, 'k'
        { 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,  },       //0x6C, 'l'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x6D, 'm'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,  },       //0x6E, 'n'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x6F, 'o'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,  },       //0x70, 'p'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,  },       //0x71, 'q'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,  },       //0x72, 'r'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,  },       //0x73, 's'
        { 0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,  },       //0x74, 't'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,  },       //0x75, 'u'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,  },       //0x76, 'v'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,  },       //0x77, 'w'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,  },       //0x78, 'x'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,  },       //0x79, 'y'
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,  },       //0x7A, 'z'
        { 0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,  },       //0x7B, '{'
        { 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,  },       //0x7C, '|'
        { 0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,  },       //0x7D, '}'
        { 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  }        //0x7E, '~'
};

static uint16_t font16x15 [96][15] = {
    /**   **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** ! **/
    {0x0000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000},
    /** " **/
    {0x0000,0x1800,0x1800,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** # **/
    {0x0000,0x0480,0x0480,0x0480,0x1FC0,0x0900,0x0900,0x0900,0x3FC0,0x0900,0x1200,0x1200,0x0000,0x0000,0x0000},
    /** $ **/
    {0x0400,0x0F00,0x1080,0x1080,0x1000,0x0800,0x0700,0x0080,0x0080,0x1080,0x1080,0x0F00,0x0400,0x0000,0x0000},
    /** % **/
    {0x0000,0x1C00,0x1240,0x1280,0x1280,0x1D00,0x0100,0x0270,0x0490,0x0490,0x0890,0x0070,0x0000,0x0000,0x0000},
    /** & **/
    {0x0000,0x0600,0x0900,0x1100,0x1200,0x0C00,0x0C00,0x1240,0x1140,0x10C0,0x1080,0x0F60,0x0000,0x0000,0x0000},
    /** ' **/
    {0x0000,0x2000,0x2000,0x2000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** ( **/
    {0x0400,0x0800,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0800,0x0400},
    /** ) **/
    {0x2000,0x1000,0x0800,0x0800,0x0800,0x0800,0x0400,0x0400,0x0400,0x0800,0x0800,0x0800,0x0800,0x1000,0x2000},
    /** * **/
    {0x0000,0x0800,0x0800,0x2900,0x1E00,0x1400,0x1200,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** + **/
    {0x0000,0x0000,0x0000,0x0400,0x0400,0x0400,0x0400,0x3FC0,0x0400,0x0400,0x0400,0x0400,0x0000,0x0000,0x0000},
    /** , **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1000,0x1000,0x1000,0x0000},
    /** - **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3C00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** . **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000},
    /** / **/
    {0x0000,0x0200,0x0200,0x0400,0x0400,0x0400,0x0800,0x0800,0x0800,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000},
    /** 0 **/
    {0x0000,0x0F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** 1 **/
    {0x0000,0x0600,0x1A00,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0000,0x0000,0x0000},
    /** 2 **/
    {0x0000,0x0F00,0x1080,0x1080,0x0080,0x0100,0x0100,0x0200,0x0400,0x0800,0x1000,0x1F80,0x0000,0x0000,0x0000},
    /** 3 **/
    {0x0000,0x0F00,0x1080,0x1080,0x0080,0x0080,0x0700,0x0180,0x0080,0x1080,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** 4 **/
    {0x0000,0x0100,0x0300,0x0500,0x0500,0x0900,0x0900,0x1100,0x2100,0x3FC0,0x0100,0x0100,0x0000,0x0000,0x0000},
    /** 5 **/
    {0x0000,0x0F80,0x1000,0x1000,0x1000,0x0F00,0x1080,0x0080,0x0080,0x1080,0x0880,0x0700,0x0000,0x0000,0x0000},
    /** 6 **/
    {0x0000,0x0300,0x0C00,0x1000,0x1000,0x1F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** 7 **/
    {0x0000,0x3F80,0x0080,0x0100,0x0100,0x0100,0x0200,0x0200,0x0400,0x0400,0x0800,0x0800,0x0000,0x0000,0x0000},
    /** 8 **/
    {0x0000,0x0F00,0x1080,0x1080,0x1080,0x1080,0x0F00,0x1980,0x1080,0x1080,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** 9 **/
    {0x0000,0x0F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F80,0x0080,0x0080,0x0100,0x0E00,0x0000,0x0000,0x0000},
    /** : **/
    {0x0000,0x0000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000},
    /** ; **/
    {0x0000,0x0000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1000,0x1000,0x1000,0x0000},
    /** < **/
    {0x0000,0x0000,0x0000,0x0000,0x0080,0x0300,0x0C00,0x1000,0x0C00,0x0300,0x0080,0x0000,0x0000,0x0000,0x0000},
    /** = **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x1F80,0x0000,0x0000,0x1F80,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** > **/
    {0x0000,0x0000,0x0000,0x0000,0x1000,0x0C00,0x0300,0x0080,0x0300,0x0C00,0x1000,0x0000,0x0000,0x0000,0x0000},
    /** ? **/
    {0x0000,0x0E00,0x1100,0x1100,0x0100,0x0100,0x0200,0x0400,0x0400,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000},
    /** @ **/
    {0x0000,0x0000,0x01F0,0x060C,0x0804,0x10E2,0x1122,0x1222,0x1222,0x1222,0x1224,0x11DC,0x0800,0x0420,0x03C0},
    /** A **/
    {0x0000,0x0600,0x0600,0x0500,0x0900,0x0900,0x0880,0x1080,0x0F80,0x1040,0x2040,0x2020,0x0000,0x0000,0x0000},
    /** B **/
    {0x0000,0x1F80,0x1080,0x1040,0x1040,0x1080,0x1F00,0x10C0,0x1040,0x1040,0x1040,0x1F80,0x0000,0x0000,0x0000},
    /** C **/
    {0x0000,0x0780,0x0840,0x1020,0x1000,0x1000,0x1000,0x1000,0x1000,0x1020,0x0840,0x0780,0x0000,0x0000,0x0000},
    /** D **/
    {0x0000,0x0F80,0x0840,0x0840,0x0820,0x0820,0x0820,0x0820,0x0820,0x0840,0x0840,0x0F80,0x0000,0x0000,0x0000},
    /** E **/
    {0x0000,0x0FC0,0x0800,0x0800,0x0800,0x0800,0x0F80,0x0800,0x0800,0x0800,0x0800,0x0FC0,0x0000,0x0000,0x0000},
    /** F **/
    {0x0000,0x0FC0,0x0800,0x0800,0x0800,0x0800,0x0F80,0x0800,0x0800,0x0800,0x0800,0x0800,0x0000,0x0000,0x0000},
    /** G **/
    {0x0000,0x0780,0x0840,0x1020,0x1000,0x1000,0x1000,0x11E0,0x1020,0x1020,0x0820,0x07C0,0x0000,0x0000,0x0000},
    /** H **/
    {0x0000,0x0820,0x0820,0x0820,0x0820,0x0820,0x0FE0,0x0820,0x0820,0x0820,0x0820,0x0820,0x0000,0x0000,0x0000},
    /** I **/
    {0x0000,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0000,0x0000,0x0000},
    /** J **/
    {0x0000,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x1080,0x1080,0x1100,0x0E00,0x0000,0x0000,0x0000},
    /** K **/
    {0x0000,0x0860,0x0880,0x0900,0x0A00,0x0C00,0x0A00,0x0A00,0x0900,0x0880,0x0840,0x0820,0x0000,0x0000,0x0000},
    /** L **/
    {0x0000,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0F80,0x0000,0x0000,0x0000},
    /** M **/
    {0x0000,0x0808,0x0808,0x0818,0x0C18,0x0C28,0x0C28,0x0A28,0x0A48,0x0948,0x0988,0x0888,0x0000,0x0000,0x0000},
    /** N **/
    {0x0000,0x0820,0x0820,0x0C20,0x0C20,0x0A20,0x0920,0x0920,0x08A0,0x0860,0x0860,0x0820,0x0000,0x0000,0x0000},
    /** O **/
    {0x0000,0x0780,0x0840,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x0840,0x0780,0x0000,0x0000,0x0000},
    /** P **/
    {0x0000,0x1F80,0x1040,0x1040,0x1040,0x1040,0x1040,0x1F80,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x0000},
    /** Q **/
    {0x0000,0x0780,0x0840,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x0840,0x0780,0x0040,0x0020,0x0000},
    /** R **/
    {0x0000,0x0F80,0x0840,0x0840,0x0840,0x0840,0x0880,0x0F00,0x0880,0x0880,0x0840,0x0820,0x0000,0x0000,0x0000},
    /** S **/
    {0x0000,0x0F80,0x1040,0x1040,0x1000,0x0E00,0x0380,0x0040,0x0040,0x1040,0x1040,0x0F80,0x0000,0x0000,0x0000},
    /** T **/
    {0x0000,0x3FE0,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0200,0x0000,0x0000,0x0000},
    /** U **/
    {0x0000,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x0840,0x0780,0x0000,0x0000,0x0000},
    /** V **/
    {0x0000,0x2020,0x2040,0x1040,0x1080,0x1080,0x0880,0x0900,0x0900,0x0500,0x0600,0x0600,0x0000,0x0000,0x0000},
    /** W **/
    {0x0000,0x1082,0x10C2,0x1142,0x1144,0x1124,0x0924,0x0A24,0x0A28,0x0A18,0x0408,0x0408,0x0000,0x0000,0x0000},
    /** X **/
    {0x0000,0x2040,0x1080,0x0880,0x0900,0x0600,0x0200,0x0500,0x0900,0x0880,0x1040,0x2060,0x0000,0x0000,0x0000},
    /** Y **/
    {0x0000,0x2060,0x1040,0x1080,0x0880,0x0900,0x0600,0x0200,0x0200,0x0200,0x0200,0x0200,0x0000,0x0000,0x0000},
    /** Z **/
    {0x0000,0x1FC0,0x0080,0x0080,0x0100,0x0200,0x0200,0x0400,0x0800,0x1000,0x1000,0x1FC0,0x0000,0x0000,0x0000},
    /** [ **/
    {0x1800,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1800,0x0000},
    /** \ **/
    {0x0000,0x2000,0x2000,0x1000,0x1000,0x0800,0x0800,0x0800,0x0400,0x0400,0x0400,0x0200,0x0200,0x0000,0x0000},
    /** ] **/
    {0x6000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x6000,0x0000},
    /** ^ **/
    {0x0000,0x0800,0x0C00,0x1400,0x1200,0x1200,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** _ **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7E00,0x0000,0x0000},
    /** ` **/
    {0x0000,0x1000,0x0800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
    /** a **/
    {0x0000,0x0000,0x0000,0x0000,0x0F00,0x1080,0x0080,0x0F80,0x1080,0x1080,0x1180,0x0E80,0x0000,0x0000,0x0000},
    /** b **/
    {0x0000,0x1000,0x1000,0x1000,0x1F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1F00,0x0000,0x0000,0x0000},
    /** c **/
    {0x0000,0x0000,0x0000,0x0000,0x0F00,0x1080,0x1080,0x1000,0x1000,0x1000,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** d **/
    {0x0000,0x0080,0x0080,0x0080,0x0F80,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F80,0x0000,0x0000,0x0000},
    /** e **/
    {0x0000,0x0000,0x0000,0x0000,0x0F00,0x1080,0x1080,0x1F80,0x1000,0x1000,0x0800,0x0780,0x0000,0x0000,0x0000},
    /** f **/
    {0x0600,0x0800,0x1000,0x1000,0x1C00,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x0000},
    /** g **/
    {0x0000,0x0000,0x0000,0x0000,0x0F80,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F80,0x0080,0x1100,0x0F00},
    /** h **/
    {0x0000,0x1000,0x1000,0x1000,0x1700,0x1880,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0000,0x0000,0x0000},
    /** i **/
    {0x0000,0x1000,0x0000,0x0000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x0000},
    /** j **/
    {0x0000,0x2000,0x0000,0x0000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0xC000},
    /** k **/
    {0x0000,0x1000,0x1000,0x1000,0x1180,0x1200,0x1400,0x1800,0x1400,0x1200,0x1100,0x1080,0x0000,0x0000,0x0000},
    /** l **/
    {0x0000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x0000},
    /** m **/
    {0x0000,0x0000,0x0000,0x0000,0x1738,0x18C4,0x1084,0x1084,0x1084,0x1084,0x1084,0x1084,0x0000,0x0000,0x0000},
    /** n **/
    {0x0000,0x0000,0x0000,0x0000,0x1700,0x1880,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0000,0x0000,0x0000},
    /** o **/
    {0x0000,0x0000,0x0000,0x0000,0x0F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F00,0x0000,0x0000,0x0000},
    /** p **/
    {0x0000,0x0000,0x0000,0x0000,0x1F00,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1F00,0x1000,0x1000,0x1000},
    /** q **/
    {0x0000,0x0000,0x0000,0x0000,0x0F80,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F80,0x0080,0x0080,0x0080},
    /** r **/
    {0x0000,0x0000,0x0000,0x0000,0x1600,0x1800,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000,0x0000,0x0000},
    /** s **/
    {0x0000,0x0000,0x0000,0x0000,0x0E00,0x1100,0x1000,0x0C00,0x0300,0x0100,0x1100,0x0E00,0x0000,0x0000,0x0000},
    /** t **/
    {0x0000,0x0000,0x1000,0x1000,0x3C00,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0C00,0x0000,0x0000,0x0000},
    /** u **/
    {0x0000,0x0000,0x0000,0x0000,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x1080,0x0F80,0x0000,0x0000,0x0000},
    /** v **/
    {0x0000,0x0000,0x0000,0x0000,0x2080,0x2100,0x1100,0x1200,0x1200,0x0A00,0x0C00,0x0400,0x0000,0x0000,0x0000},
    /** w **/
    {0x0000,0x0000,0x0000,0x0000,0x2118,0x2310,0x1310,0x12A0,0x14A0,0x14A0,0x0C60,0x0840,0x0000,0x0000,0x0000},
    /** x **/
    {0x0000,0x0000,0x0000,0x0000,0x2180,0x1200,0x0A00,0x0C00,0x0C00,0x0A00,0x1100,0x2180,0x0000,0x0000,0x0000},
    /** y **/
    {0x0000,0x0000,0x0000,0x0000,0x2080,0x2100,0x1100,0x1200,0x1200,0x0A00,0x0C00,0x0400,0x0400,0x0800,0x1800},
    /** z **/
    {0x0000,0x0000,0x0000,0x0000,0x1F00,0x0100,0x0200,0x0400,0x0800,0x1000,0x1000,0x1F80,0x0000,0x0000,0x0000},
    /** { **/
    {0x0600,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x1000,0x0800,0x0800,0x0800,0x0800,0x0800,0x0800,0x0600},
    /** | **/
    {0x0000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x1000,0x0000},
    /** } **/
    {0x2000,0x1000,0x1000,0x0800,0x0800,0x0800,0x0800,0x0400,0x0800,0x0800,0x0800,0x0800,0x1000,0x1000,0x2000},
    /** ~ **/
    {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0C20,0x1320,0x11C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
};

/**
 * @brief Sets the desired font to be used when displaying characters on the display.
 * \b WARNING Page addressing mode uses only the default 8x8 font
 * @param pSSD1306Handle Device handle
 * @param Font The desired font
 * @param Mirrored Some fonts require to be mirrored
 */
SSD1306_Error_e SSD1306_SetFont(SSD1306_Handle_t *pSSD1306Handle, SSD1306_Font_e Font, uint8_t Mirrored) {
    if (pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrPage && Font != SSD1306_Font8x8) {
        return SSD1306_ErrInvalidFont;
    }

    pSSD1306Handle->FontConfig.Font = Font;
    pSSD1306Handle->FontConfig.Mirrored = Mirrored;

    switch (Font) {
        case SSD1306_Font8x8:
            pSSD1306Handle->FontConfig.Width = 8;
            pSSD1306Handle->FontConfig.Height = 8;
        break;
        case SSD1306_Font8x16:
            pSSD1306Handle->FontConfig.Width = 8;
            pSSD1306Handle->FontConfig.Height = 16;
        break;
        case SSD1306_Font16x15:
            pSSD1306Handle->FontConfig.Width = 16;
            pSSD1306Handle->FontConfig.Height = 15;
        break;
    }

    return SSD1306_ErrOK;
}

/**
 * @brief Sets the display cursor in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param Column The desired column (X Axis)
 * @param Page The desired page (Y Axis)
 */
SSD1306_Error_e SSD1306_SetCursor(SSD1306_Handle_t *pSSD1306Handle, uint8_t Column, SSD1306_Page_e Page) {
    if (Column < SSD1306_MIN_COL_ADDR || Column > SSD1306_MAX_COL_ADDR) return SSD1306_ErrInvalidArg;
    if (pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrPage) return SSD1306_ErrInvalidAddrMode;

    SSD1306_Error_e err = SSD1306_ErrOK;

    // Y Axis
    if ((err = SSD1306_SetPageModeStartPage(pSSD1306Handle, Page)) != SSD1306_ErrOK) return err;

    // X Axis
    uint8_t lowerNibble = Column & 0xF;
    uint8_t higherNibble = 0x10 | ((Column >> 4) & 0xF);
    if ((err = SSD1306_SetPageModeColumnLowerNibble(pSSD1306Handle, lowerNibble)) != SSD1306_ErrOK) return err;
    if ((err = SSD1306_SetPageModeColumnHigherNibble(pSSD1306Handle, higherNibble)) != SSD1306_ErrOK) return err;

    return err;
}

/**
 * @brief Writes a string on the display when in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param str String to be written
 */
SSD1306_Error_e SSD1306_Write(SSD1306_Handle_t *pSSD1306Handle, char *str) {
    if (pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrPage) return SSD1306_ErrInvalidAddrMode;

    SSD1306_Error_e err = SSD1306_ErrOK;

    while (*str) {
        uint8_t fontChar[pSSD1306Handle->FontConfig.Width];
        get_8x8_char_bitmap(pSSD1306Handle, *str++, fontChar);
        if ((err = send_data(pSSD1306Handle, fontChar, pSSD1306Handle->FontConfig.Width)) != SSD1306_ErrOK) return err;
    }

    return err;
}

/**
 * @brief Clear the display in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_Clear(SSD1306_Handle_t *pSSD1306Handle) {
    if (pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrPage) return SSD1306_ErrInvalidAddrMode;

    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t emptyLine[SSD1306_MAX_WIDTH] = {0};

    for (int i = 0; i <= SSD1306_MAX_PAGE_ADDR; i++) {
        if ((err = SSD1306_SetPageModeStartPage(pSSD1306Handle, i)) != SSD1306_ErrOK) return err;
        if ((err = SSD1306_SetPageModeColumnLowerNibble(pSSD1306Handle, SSD1306_MIN_PAGE_LWR_COL_ADDR)) != SSD1306_ErrOK) return err;
        if ((err = SSD1306_SetPageModeColumnHigherNibble(pSSD1306Handle, SSD1306_MIN_PAGE_HIGH_COL_ADDR)) != SSD1306_ErrOK) return err;
        if ((err = send_data(pSSD1306Handle, emptyLine, sizeof(emptyLine))) != SSD1306_ErrOK) return err;
    }

    return err;
}

/**
 * @brief Sets the write area in HORIZONTAL ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param xStart Desired start x position
 * @param xEnd Desired end x position
 * @param yStart Desired start y position
 * @param yEnd Desired end y position
 */
SSD1306_Error_e SSD1306_SetWriteAreaH(SSD1306_Handle_t *pSSD1306Handle, uint8_t xStart, uint8_t xEnd, uint8_t yStart, uint8_t yEnd) {
    if (xStart < SSD1306_MIN_WIDTH || xEnd > SSD1306_MAX_WIDTH || yStart < SSD1306_MIN_HEIGHT || yEnd > SSD1306_MAX_HEIGHT) return SSD1306_ErrInvalidArg;
    if (xStart > xEnd || yStart > yEnd) return SSD1306_ErrInvalidArg;
    if (
        pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrHorizontal
    ) {
            return SSD1306_ErrInvalidAddrMode;
    }

    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t pageStart = yStart / 8;
    uint8_t pageEnd = yEnd / 8;

    err = SSD1306_SetHModePageAddr(pSSD1306Handle, pageStart, pageEnd);
    if (err != SSD1306_ErrOK) return err;

    err = SSD1306_SetHModeColumnAddr(pSSD1306Handle, xStart, xEnd);
    if (err != SSD1306_ErrOK) return err;

    return err;
}

/**
 * @brief Writes text to the specified coordinates of the screen
 * @param pSSD1306Handle Device handle
 * @param x Horizontal start position
 * @param y Vertical start position
 * @param str The string to be written
 */
SSD1306_Error_e SSD1306_WriteH(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, char *str) {
    if (
        pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrHorizontal
    ) {
        return SSD1306_ErrInvalidAddrMode;
    }

    SSD1306_Error_e err = SSD1306_ErrOK;
    uint8_t maxPage = pSSD1306Handle->DeviceState.AddressingState.PageEndAddr > 3 ? 4 : pSSD1306Handle->DeviceState.AddressingState.PageEndAddr;
    if (x + strlen(str) * pSSD1306Handle->FontConfig.Width > pSSD1306Handle->DeviceState.AddressingState.ColEndAddr + 1 || y + pSSD1306Handle->FontConfig.Height > maxPage * 8) {
        return SSD1306_ErrOutOfBounds;
    }

    if (pSSD1306Handle->FontConfig.Width > 16) {
        write_hor_font_over_16(pSSD1306Handle, x, y, (uint8_t*)str);
    } else if (pSSD1306Handle->FontConfig.Width > 8) {
        write_hor_font_over_8(pSSD1306Handle, x, y, (uint8_t*)str);
    } else {
        write_hor_font_8(pSSD1306Handle, x, y, (uint8_t*)str);
    }

    return err;
}

SSD1306_Error_e SSD1306_DrawH(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t *bitmap, uint8_t len) {
    if (
        pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrHorizontal
    ) {
        return SSD1306_ErrInvalidAddrMode;
    }

    SSD1306_Error_e err = SSD1306_ErrOK;
    uint8_t bytesPerColumn = (height + 7) / 8;

    uint8_t maxPage = pSSD1306Handle->DeviceState.AddressingState.PageEndAddr > 3 ? 4 : pSSD1306Handle->DeviceState.AddressingState.PageEndAddr;
    if (x + width > pSSD1306Handle->DeviceState.AddressingState.ColEndAddr + 1 || y + height > maxPage * 8 || width * bytesPerColumn > len) {
        return SSD1306_ErrOutOfBounds;
    }

    if (width > height) {
        // Several bytes represent a single row
        uint8_t bytesPerRow = width / 8;
        for (int row = 0; row < height; row++) {
            for (int rowChunk = 0; rowChunk < bytesPerRow; rowChunk++) {
                // One part of the row
                uint8_t rowChunkContent = bitmap[row * bytesPerRow + rowChunk];
                for (int bit = 0; bit < 8; bit++) {
                    uint8_t col = rowChunk * 8 + bit;
                    // One column of the row
                    h_addr_set_pixel(
                        x + col,
                        y + row,
                        (rowChunkContent >> (7 - bit)) & 0x01          // MSB first
                    );
                }
            }
        }
    } else if (height > width) {
        // Several bytes represent a single column
        uint8_t bytesPerCol = height / 8;
        for (int col = 0; col < width; col++) {
            for (int colChunk = 0; colChunk < bytesPerCol; colChunk++) {
                // One part of the column
                uint8_t colChunkContent = bitmap[col * bytesPerCol + colChunk];
                for (int bit = 0; bit < 8; bit++) {
                    uint8_t row = colChunk * 8 + bit;
                    // One column of the row
                    h_addr_set_pixel(
                        x + col,
                        y + row,
                        (colChunkContent >> (7 - bit)) & 0x01          // MSB first
                    );
                }
            }
        }
    } else {
        // Several bytes represent a single column and a single row
        uint8_t bytesPerRow = width / 8;
        for (int row = 0; row < height; row++) {
            for (int rowChunk = 0; rowChunk < bytesPerRow; rowChunk++) {
                // One part of the row
                uint8_t rowChunkContent = bitmap[row * bytesPerRow + rowChunk];
                for (int bit = 0; bit < 8; bit++) {
                    uint8_t col = rowChunk * 8 + bit;
                    // One column of the row
                    h_addr_set_pixel(
                        x + col,
                        y + row,
                        ((rowChunkContent >> (7 - bit)) & 0x01)          // MSB first
                    );
                }
            }
        }
    }

    return err;
}

/**
 * @brief Clears the selected display area in HORIZONTAL ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_ClearH(SSD1306_Handle_t *pSSD1306Handle) {
    if (
        pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrHorizontal
    ) {
        return SSD1306_ErrInvalidAddrMode;
    }
    memset(frameBuffer, 0, sizeof(frameBuffer));

    return SSD1306_ErrOK;
}

/**
 * @brief Updates the whole display in HORIZONTAL ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_UpdateH(SSD1306_Handle_t *pSSD1306Handle) {
    if (
        pSSD1306Handle->DeviceState.AddressingState.AddressingMode != SSD1306_MemAddrHorizontal
    ) {
        return SSD1306_ErrInvalidAddrMode;
    }

    return send_data(pSSD1306Handle, frameBuffer, sizeof(frameBuffer));
}

/**
 * @brief Initializes the SSD1306 display
 * @note Before calling this method the required GPIOS and I2C peripheral \b MUST be configured.\n\n
 * @note The display requires minimum I2C clock speed of 400KHz
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_Init(SSD1306_Handle_t *pSSD1306Handle, SSD1306_Config_t Config) {
    if (!I2C_PeripheralEnabled(pSSD1306Handle->I2CHandle->pI2Cx)) return SSD1306_ErrI2CNotEnabled;
    if (pSSD1306Handle->I2CHandle->I2C_Config.I2C_SCLSpeed != I2C_SclSpeedFM4K) return SSD1306_ErrI2CIncorrectSpeed;
    reset_state(pSSD1306Handle);

    // Reset display
    SSD1306_PowerControl(pSSD1306Handle, DISABLE);
    Generic_Delay(100);
    SSD1306_PowerControl(pSSD1306Handle, ENABLE);
    Generic_Delay(100);

    // MUX ratio
    SSD1306_Error_e err = SSD1306_SetMuxRatio(pSSD1306Handle, Config.MUXRatio);
    if (err != SSD1306_ErrOK) return err;

    // Display offset
    err = SSD1306_SetDisplayOffset(pSSD1306Handle, Config.DisplayOffset);
    if (err != SSD1306_ErrOK) return err;

    // Display start line
    err = SSD1306_SetStartLine(pSSD1306Handle, Config.DisplayStartLine);
    if (err != SSD1306_ErrOK) return err;

    // Segment remapping
    err = SSD1306_SetSegmentRemap(pSSD1306Handle, Config.SegmentsRemapped);
    if (err != SSD1306_ErrOK) return err;

    // COM scan direction
    err = SSD1306_SetCOMScanRemapping(pSSD1306Handle, Config.COMScanRemapped);
    if (err != SSD1306_ErrOK) return err;

    // COM hardware configuration
    err = SSD1306_ConfigureCOMPins(pSSD1306Handle, Config.AlternativeCOMPinConfigEnabled, Config.COMLeftRightRemapEnabled);
    if (err != SSD1306_ErrOK) return err;

    // Contrast
    err = SSD1306_SetContrast(pSSD1306Handle, Config.Contrast);
    if (err != SSD1306_ErrOK) return err;

    // Display clock
    err = SSD1306_SetDivideRatioAndOSCFreq(pSSD1306Handle, Config.DivideRatio, Config.OSCFreq);
    if (err != SSD1306_ErrOK) return err;

    // Charge pump
    err = SSD1306_ChargePumpControl(pSSD1306Handle, ENABLE);
    if (err != SSD1306_ErrOK) return err;

    // Font
    err = SSD1306_SetFont(pSSD1306Handle, Config.Font, Config.FontMirrored);
    if (err != SSD1306_ErrOK) return err;

    return SSD1306_ErrOK;
}

/**
 * @brief De-initializes the display
 * @param pSSD1306Handle Device handle
 */
void SSD1306_DeInit(SSD1306_Handle_t *pSSD1306Handle) {
    reset_state(pSSD1306Handle);
}

/**
 * @brief Sets the desired display contrast
 * @param pSSD1306Handle Device handle
 * @param Value Value between 0 and 255
 */
SSD1306_Error_e SSD1306_SetContrast(SSD1306_Handle_t *pSSD1306Handle, uint8_t Value) {
    if (Value < SSD1306_MIN_CONTRAST || Value > SSD1306_MAX_CONTRAST) return SSD1306_ErrInvalidArg;

    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_CONTRAST, Value);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.Contrast = Value;
    return err;
}

/**
 * @brief Resumes the display with the data inside the device's RAM
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_ResumeDisplay(SSD1306_Handle_t *pSSD1306Handle) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_RESUME_DISPLAY_ON);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.EntireDisplayON = DISABLE;
    return err;
}

/**
 * @brief Enables all display pixels in order to debug the device
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_SetEntireDisplayON(SSD1306_Handle_t *pSSD1306Handle) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_ENTIRE_DISPLAY_ON);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.EntireDisplayON = ENABLE;
    return err;
}

/**
 * @brief Controls whether the display should be in normal or in sleep mode
 * @param pSSD1306Handle Device handle
 * @param Enabled If the display should be enabled or in sleep mode
 */
SSD1306_Error_e SSD1306_DisplayControl(SSD1306_Handle_t *pSSD1306Handle, uint8_t Enabled) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    if (Enabled) {
        SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_NORMAL_MODE);
        pSSD1306Handle->DeviceState.DisplayMode = SSD1306_DisplayModeNormal;
    } else {
        SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_SLEEP_MODE);
        pSSD1306Handle->DeviceState.DisplayMode = SSD1306_DisplayModeSleep;
    }

    if (err != SSD1306_ErrOK) return err;
    return err;
}

/**
 * @brief Setups the display for horizontal scrolling
 * @param pSSD1306Handle Device handle
 * @param Direction The desired scroll direction (only left / right)
 * @param StartPage The desired start page
 * @param EndPage The desired end page
 * @param StepInterval The time interval between each scroll step in terms of frame frequency
 */
SSD1306_Error_e SSD1306_SetupHorizontalScroll(SSD1306_Handle_t *pSSD1306Handle, SSD1306_ScrollDirection_e Direction,
                                              SSD1306_Page_e StartPage, SSD1306_Page_e EndPage, SSD1306_ScrollStepInterval_e StepInterval) {
    if (Direction >= SSD1306_VHScrollLeft || EndPage < StartPage) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t dirCommand = Direction == SSD1306_HScrollLeft ? SSD1306_CMD_SET_CONT_H_LEFT_SCROLLING_SETUP : SSD1306_CMD_SET_CONT_H_RIGHT_SCROLLING_SETUP;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, dirCommand, 0x00, StartPage, StepInterval, EndPage, 0x00, 0xFF);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.ScrollState.Direction = Direction;
    pSSD1306Handle->DeviceState.ScrollState.StartPageAddress = StartPage;
    pSSD1306Handle->DeviceState.ScrollState.EndPageAddress = EndPage;
    pSSD1306Handle->DeviceState.ScrollState.ScrollStepInterval = StepInterval;
    return err;
}

/**
 * @brief Setups the display for vertical and horizontal scrolling
 * @param pSSD1306Handle Device handle
 * @param Direction The desired scroll direction
 * @param StartPage The desired start page
 * @param EndPage The desired end page
 * @param StepInterval The time interval between each scroll step in terms of frame frequency
 * @param VerticalOffset Vertical scrolling offset
 */
SSD1306_Error_e SSD1306_SetupVerticalHorizontalScroll(SSD1306_Handle_t *pSSD1306Handle,
                                                      SSD1306_ScrollDirection_e Direction, SSD1306_Page_e StartPage, SSD1306_Page_e EndPage,
                                                      SSD1306_ScrollStepInterval_e StepInterval, uint8_t VerticalOffset) {
    if (Direction < SSD1306_VHScrollLeft || EndPage < StartPage || VerticalOffset < SSD1306_MIN_V_OFFSET || VerticalOffset > SSD1306_MAX_V_OFFSET) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t dirCommand = Direction == SSD1306_VHScrollLeft ? SSD1306_CMD_SET_CONT_VH_LEFT_SCROLLING_SETUP : SSD1306_CMD_SET_CONT_VH_RIGHT_SCROLLING_SETUP;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, dirCommand, 0x00, StartPage, StepInterval, EndPage, VerticalOffset);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.ScrollState.Direction = Direction;
    pSSD1306Handle->DeviceState.ScrollState.StartPageAddress = StartPage;
    pSSD1306Handle->DeviceState.ScrollState.EndPageAddress = EndPage;
    pSSD1306Handle->DeviceState.ScrollState.ScrollStepInterval = StepInterval;
    pSSD1306Handle->DeviceState.ScrollState.VerticalOffset = VerticalOffset;

    return err;
}

/**
 * @brief Disables the scrolling
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_DeactivateScroll(SSD1306_Handle_t *pSSD1306Handle) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_SCROLL_DISABLE);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.ScrollState.Enabled = DISABLE;
    return err;
}

/**
 * @brief Enables the scrolling
 * @param pSSD1306Handle Device handle
 */
SSD1306_Error_e SSD1306_ActivateScroll(SSD1306_Handle_t *pSSD1306Handle) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_SCROLL_ENABLE);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.ScrollState.Enabled = ENABLE;
    return err;
}

/**
 * @brief Sets the area which should be scrolled
 * @param pSSD1306Handle Device handle
 * @param StartRow The start row from which the display scrolls
 * @param NumberOfRows The number of rows bellow the start row
 */
SSD1306_Error_e SSD1306_SetVerticalScrollArea(SSD1306_Handle_t *pSSD1306Handle, uint8_t StartRow, uint8_t NumberOfRows) {
    if (StartRow + NumberOfRows > pSSD1306Handle->DeviceState.HardwareState.MuxRatio) return SSD1306_ErrInvalidArg;
    if (NumberOfRows > pSSD1306Handle->DeviceState.HardwareState.MuxRatio) return SSD1306_ErrInvalidArg;
    if (pSSD1306Handle->DeviceState.ScrollState.VerticalOffset < NumberOfRows) return SSD1306_ErrInvalidArg;

    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_V_SCROLL_AREA, StartRow, NumberOfRows);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.ScrollState.StartRow = StartRow;
    pSSD1306Handle->DeviceState.ScrollState.NumberOfRows = NumberOfRows;
    return err;
}

/**
 * @brief Sets the lower nibble of the column start address
 * @note This method is valid ONLY when the device is in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param ColLowerAddr The lower nibble
 */
SSD1306_Error_e SSD1306_SetPageModeColumnLowerNibble(SSD1306_Handle_t *pSSD1306Handle, uint8_t ColLowerAddr) {
    if (ColLowerAddr < SSD1306_MIN_PAGE_LWR_COL_ADDR || ColLowerAddr > SSD1306_MAX_PAGE_LWR_COL_ADDR) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, ColLowerAddr);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.ColLowerNibble = ColLowerAddr;
    return err;
}

/**
 * @brief Sets the higher nibble of the column start address
 * @note This method is valid ONLY when the device is in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param ColHigherAddr The higher nibble
 */
SSD1306_Error_e SSD1306_SetPageModeColumnHigherNibble(SSD1306_Handle_t *pSSD1306Handle, uint8_t ColHigherAddr) {
    if (ColHigherAddr < SSD1306_MIN_PAGE_HIGH_COL_ADDR || ColHigherAddr > SSD1306_MAX_PAGE_HIGH_COL_ADDR) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, ColHigherAddr);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.ColHigherNibble = ColHigherAddr;
    return err;
}

/**
 * @brief Sets the start page address
 * @note This method is valid ONLY when the device is in PAGE ADDRESSING MODE
 * @param pSSD1306Handle Device handle
 * @param Page The desired start page
 */
SSD1306_Error_e SSD1306_SetPageModeStartPage(SSD1306_Handle_t *pSSD1306Handle, SSD1306_Page_e Page) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, 0xB0 | Page);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.PageStartAddr = Page;
    return err;
}

/**
 * @brief Sets the memory address mode
 * @param pSSD1306Handle Device handle
 * @param Mode The desired page addressing mode
 */
SSD1306_Error_e SSD1306_SetMemoryAddrMode(SSD1306_Handle_t *pSSD1306Handle, SSD1306_MemoryAddressingMode_e Mode) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_MEM_ADDR_MODE, Mode);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.AddressingMode = Mode;
    return err;
}

/**
 * @brief Sets the column start and end addresses
 * @note This method is valid ONLY when the device is in HORIZONTAL OR VERTICAL ACCESSING MODE
 * @param pSSD1306Handle Device handle
 * @param StartAddr The desired column start address
 * @param EndAddr The desired column end address
 */
SSD1306_Error_e SSD1306_SetHModeColumnAddr(SSD1306_Handle_t *pSSD1306Handle, uint8_t StartAddr, uint8_t EndAddr) {
    if (StartAddr < SSD1306_MIN_COL_ADDR || StartAddr > SSD1306_MAX_COL_ADDR || EndAddr < SSD1306_MIN_COL_ADDR || EndAddr > SSD1306_MAX_COL_ADDR) {
        return SSD1306_ErrInvalidArg;
    }
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_COL_ADDR, StartAddr, EndAddr);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.ColStartAddr = StartAddr;
    pSSD1306Handle->DeviceState.AddressingState.ColEndAddr = EndAddr;
    return err;
}

/**
 * @brief Sets the desired start and end page addresses
 * @note This method is valid ONLY when the device is in HORIZONTAL ACCESSING MODE
 * @param pSSD1306Handle Device handle
 * @param StartPage The desired start page
 * @param EndPage The desired end page
 */
SSD1306_Error_e SSD1306_SetHModePageAddr(SSD1306_Handle_t *pSSD1306Handle, SSD1306_Page_e StartPage,
                                          SSD1306_Page_e EndPage) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_PAGE_ADDR, StartPage, EndPage);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.AddressingState.PageStartAddr = StartPage;
    pSSD1306Handle->DeviceState.AddressingState.PageEndAddr = EndPage;
    return err;
}

/**
 * @brief Sets the start line of the display
 * @param pSSD1306Handle Device handle
 * @param StartLine The desired start line
 */
SSD1306_Error_e SSD1306_SetStartLine(SSD1306_Handle_t *pSSD1306Handle, uint8_t StartLine) {
    if (StartLine < SSD1306_DISPLAY_STRT_LINE_MIN || StartLine > SSD1306_DISPLAY_STRT_LINE_MAX) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, (0x40 | StartLine));
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.StartLine = StartLine;
    return err;
}

/**
 * @brief Controls whether the display segments should be remapped so that col 127 is mapped to SEG0
 * @param pSSD1306Handle Device handle
 * @param Enabled If the segments should be remapped
 */
SSD1306_Error_e SSD1306_SetSegmentRemap(SSD1306_Handle_t *pSSD1306Handle, uint8_t Enabled) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, Enabled ? SSD1306_CMD_SET_REMAP_START_127 : SSD1306_CMD_SET_REMAP_START_0);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.SegmentRemapped = Enabled;
    return err;
}

/**
 * @brief Controls how much rows should be visible
 * @param pSSD1306Handle Device handle
 * @param Ratio Ratio between 15 and 63
 */
SSD1306_Error_e SSD1306_SetMuxRatio(SSD1306_Handle_t *pSSD1306Handle, uint8_t Ratio) {
    if (Ratio < SSD1306_MIN_MUX_RATIO || Ratio > SSD1306_MAX_MUX_RATIO) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_MUX_RATIO, Ratio);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.MuxRatio = Ratio;
    return err;
}

/**
 * @brief Controls the com output scan direction
 * @param pSSD1306Handle Device handle
 * @param Enabled If the reverse com scan direction should be enabled
 */
SSD1306_Error_e SSD1306_SetCOMScanRemapping(SSD1306_Handle_t *pSSD1306Handle, uint8_t Enabled) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, Enabled ? SSD1306_CMD_SET_COM_SCAN_DIR_REVERSE : SSD1306_CMD_SET_COM_SCAN_DIR_NORMAL);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.COMScanRemapped = Enabled;
    return err;
}

/**
 * @brief Controls the display vertical offset
 * @param pSSD1306Handle Device handle
 * @param Value The desired vertical offset
 */
SSD1306_Error_e SSD1306_SetDisplayOffset(SSD1306_Handle_t *pSSD1306Handle, uint8_t Value) {
    if (Value < SSD1306_MIN_V_OFFSET || Value > SSD1306_MAX_V_OFFSET) return SSD1306_ErrInvalidArg;
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_DISPLAY_OFFSET, Value);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.DisplayVOffset = Value;
    return err;
}

/**
 * @brief Controls the COM pin configuration and the Left/Right remap
 * @param pSSD1306Handle Device handle
 * @param AlternativeCOMPinConfigEnabled If the alternative COM pin configuration should be enabled
 * @param COMLeftRightRemapEnabled If the COM Left/Right remap should be enabled
 * @return
 */
SSD1306_Error_e SSD1306_ConfigureCOMPins(SSD1306_Handle_t *pSSD1306Handle, uint8_t AlternativeCOMPinConfigEnabled,
                                         uint8_t COMLeftRightRemapEnabled) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t finalCommand = (AlternativeCOMPinConfigEnabled ? 1 : 0) << 4;
    finalCommand |= (COMLeftRightRemapEnabled ? 1 : 0) << 5;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_COM_PINS_HDWR_CONF, finalCommand);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.HardwareState.AlternativeCOMPinConfig = AlternativeCOMPinConfigEnabled;
    pSSD1306Handle->DeviceState.HardwareState.COMLeftRightRemapEnabled = COMLeftRightRemapEnabled;
    return err;
}

/**
 * @brief Controls the display clock division and source frequency
 * @param pSSD1306Handle Device handle
 * @param DivideRatio The desired display clock divide ratio
 * @param OSCFreq Source oscillator frequency
 */
SSD1306_Error_e SSD1306_SetDivideRatioAndOSCFreq(SSD1306_Handle_t *pSSD1306Handle, uint8_t DivideRatio, uint8_t OSCFreq) {
    if (DivideRatio < SSD1306_MIN_DCLK_DIVIDE_RATIO || DivideRatio > SSD1306_MAX_DCLK_DIVIDE_RATIO || OSCFreq < SSD1306_MIN_OSC_FREQ || OSCFreq > SSD1306_MAX_OSC_FREQ) {
        return SSD1306_ErrInvalidArg;
    }

    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t finalCommand = (DivideRatio & 0xF) | ((OSCFreq & 0xF) << 4);

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_DCLK_DIV_RATIO_OSC_FREQ, finalCommand);

    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.TimingState.DCLKDivRatio = DivideRatio;
    pSSD1306Handle->DeviceState.TimingState.OSCFreq = OSCFreq;
    return err;
}

/**
 * @brief Sets the desired pre-charge phase periods
 * @param pSSD1306Handle Device handle
 * @param PhaseOnePeriod The DCLK period of the first pre-charge phase
 * @param PhaseTwoPeriod The DCLK period of the second pre-charge phase
 */
SSD1306_Error_e SSD1306_SetPreChargePeriod(SSD1306_Handle_t *pSSD1306Handle, uint8_t PhaseOnePeriod,
                                           uint8_t PhaseTwoPeriod) {
    if (PhaseOnePeriod < SSD1306_MIN_PHASE_PRECHARGE_PERIOD || PhaseOnePeriod > SSD1306_MAX_PHASE_PRECHARGE_PERIOD || PhaseTwoPeriod < SSD1306_MIN_PHASE_PRECHARGE_PERIOD || PhaseTwoPeriod > SSD1306_MAX_PHASE_PRECHARGE_PERIOD) {
        return SSD1306_ErrInvalidArg;
    }

    SSD1306_Error_e err = SSD1306_ErrOK;

    uint8_t finalCommand = (PhaseOnePeriod & 0xF) | ((PhaseTwoPeriod & 0xF) << 4);

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_PRE_CHARGE_PERIOD, finalCommand);

    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.TimingState.Phase1Period = PhaseOnePeriod;
    pSSD1306Handle->DeviceState.TimingState.Phase2Period = PhaseTwoPeriod;
    return err;
}

/**
 * @brief Controls the VCOMH deselect level
 * @param pSSD1306Handle Device handle
 * @param Level The desired VCOMH deselect level
 */
SSD1306_Error_e SSD1306_SetVCOMHDeselectLevel(SSD1306_Handle_t *pSSD1306Handle, SSD1306_VCOMHDeselectLevel_e Level) {
    SSD1306_Error_e err = SSD1306_ErrOK;

    SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_VCOMH_DES_LVL, (Level & 0x07) << 4);
    if (err != SSD1306_ErrOK) return err;

    pSSD1306Handle->DeviceState.TimingState.VCOMHDeselectLevel = Level;
    return err;
}

/**
 * @brief Enables or disables the display's charge pump
 * @param pSSD1306Handle Device handle
 * @param Enabled If the charge pump should be enabled
 */
SSD1306_Error_e SSD1306_ChargePumpControl(SSD1306_Handle_t *pSSD1306Handle, uint8_t Enabled) {
    SSD1306_Error_e err = SSD1306_ErrOK;
    if (Enabled) {
        SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_CHARGE_PUMP, 0x14);
    } else {
        SSD1306_SEND_COMMANDS(pSSD1306Handle, err, SSD1306_CMD_SET_CHARGE_PUMP, 0x10);
    }
    return err;
}

/**
 * @brief Enables or disables the display's power source
 * @param pSSD1306Handle Device handle
 * @param Enabled If the display main power source should be enabled
 */
void SSD1306_PowerControl(SSD1306_Handle_t *pSSD1306Handle, uint8_t Enabled) {
    GPIO_WriteToOutputPin(pSSD1306Handle->PowerConfig.pGPIOx, pSSD1306Handle->PowerConfig.PinNumber, Enabled ? ENABLE : DISABLE);
    pSSD1306Handle->DeviceState.PowerEnabled = Enabled;
}

SSD1306_Error_e send_commands(SSD1306_Handle_t *pSSD1306Handle, uint8_t *commands, uint32_t len) {
    if (len + 1 > SSD1306_I2C_SEND_BUFFER_LEN) return SSD1306_ErrBufferOverflow;
    if (len == 0) return SSD1306_ErrOK;

    I2C_Error_e err = I2C_ErrOK;

    memset(sendBuffer, 0, sizeof(sendBuffer));

    sendBuffer[0] = 0x00;                       // Co == 0 && D/C# == 0
    memcpy(sendBuffer + 1, commands, len);

    err = I2C_MasterSendData(pSSD1306Handle->I2CHandle, sendBuffer, len + 1, SSD1306_I2C_ADDR, I2C_StopEnabled);

    return err == I2C_ErrOK ? SSD1306_ErrOK : SSD1306_ErrComm;
}

SSD1306_Error_e send_data(SSD1306_Handle_t *pSSD1306Handle, uint8_t *data, uint32_t len) {
    if (len + 1 > SSD1306_I2C_SEND_BUFFER_LEN) return SSD1306_ErrBufferOverflow;
    I2C_Error_e err = I2C_ErrOK;

    memset(sendBuffer, 0, sizeof(sendBuffer));

    uint32_t totalLen = len + 1;
    uint32_t offset = 0;
    while (offset < totalLen) {
        uint8_t chunkSize = (totalLen - offset) > 16 ? 16 : (totalLen - offset);

        uint8_t buffer[chunkSize + 1];

        // Control byte
        buffer[0] = (1 << SSD1306_COMM_DC_BIT_POS);  // Co == 0 && D/C# == 1
        memcpy(buffer + 1, data + offset, chunkSize);

        err = I2C_MasterSendData(pSSD1306Handle->I2CHandle, buffer, chunkSize + 1, SSD1306_I2C_ADDR, I2C_StopEnabled);
        if (err != I2C_ErrOK) return SSD1306_ErrComm;

        offset += chunkSize;
    }

    return err;
}

void write_hor_font_over_16(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str) {
    uint32_t currLetter = 0;
    uint8_t isMirrored = pSSD1306Handle->FontConfig.Mirrored;
    while (*str) {
        uint32_t *fontChar = get_char_bitmap(pSSD1306Handle, *str++);
        for (uint32_t row = 0; row < pSSD1306Handle->FontConfig.Height; row++) {
            uint32_t rowContent = fontChar[row];
            for (int col = 0; col < pSSD1306Handle->FontConfig.Width; col++) {
                h_addr_set_pixel((currLetter * pSSD1306Handle->FontConfig.Width) + (x + col), y + row, (rowContent >> (isMirrored ? col : pSSD1306Handle->FontConfig.Width - 1 - col)) & 0x01);
            }
        }
        currLetter++;
    }
}

void write_hor_font_over_8(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str) {
    uint32_t currLetter = 0;
    uint8_t isMirrored = pSSD1306Handle->FontConfig.Mirrored;
    while (*str) {
        uint16_t *fontChar = get_char_bitmap(pSSD1306Handle, *str++);
        for (uint16_t row = 0; row < pSSD1306Handle->FontConfig.Height; row++) {
            uint16_t rowContent = fontChar[row];
            for (int col = 0; col < pSSD1306Handle->FontConfig.Width; col++) {
                h_addr_set_pixel((currLetter * pSSD1306Handle->FontConfig.Width) + (x + col), y + row, (rowContent >> (isMirrored ? col : pSSD1306Handle->FontConfig.Width - 1 - col)) & 0x01);
            }
        }
        currLetter++;
    }
}

void write_hor_font_8(SSD1306_Handle_t *pSSD1306Handle, uint8_t x, uint8_t y, uint8_t *str) {
    uint32_t currLetter = 0;
    uint8_t isMirrored = pSSD1306Handle->FontConfig.Mirrored;
    while (*str) {
        uint8_t *fontChar = get_char_bitmap(pSSD1306Handle, *str++);
        for (uint8_t row = 0; row < pSSD1306Handle->FontConfig.Height; row++) {
            uint8_t rowContent = fontChar[row];
            for (int col = 0; col < pSSD1306Handle->FontConfig.Width; col++) {
                h_addr_set_pixel((currLetter * pSSD1306Handle->FontConfig.Width) + (x + col), y + row, (rowContent >> (isMirrored ? col : pSSD1306Handle->FontConfig.Width - 1 - col)) & 0x01);
            }
        }
        currLetter++;
    }
}

void h_addr_set_pixel(uint8_t x, uint8_t y, uint8_t on) {
    uint8_t page = y / 8;
    uint8_t bit = y % 8;
    uint32_t index = page * (SSD1306_MAX_WIDTH) + x;

    if (on) frameBuffer[index] |= (1 << bit);
    else frameBuffer[index] &=~ (1 << bit);
}

void get_8x8_char_bitmap(SSD1306_Handle_t *pSSD1306Handle, char c, uint8_t *verticalChar) {
    if (c < 32 || c > 127) c = '?';
    if (pSSD1306Handle->FontConfig.Font != SSD1306_Font8x8) return;

    convert_8x8_char_to_vertical(font8x8[(uint8_t)c - 32], verticalChar);
}

void *get_char_bitmap(SSD1306_Handle_t *pSSD1306Handle, char c) {
    if (c < 32 || c > 127) c = '?';

    switch (pSSD1306Handle->FontConfig.Font) {
        case SSD1306_Font16x15:
            return font16x15[c - 32];
        case SSD1306_Font8x16:
            return font8x16[c - 32];
        default:
            return font8x8[c - 32];
    }
}


void convert_8x8_char_to_vertical(uint8_t *ch, uint8_t *verticalChar) {
    for (int col = 0; col < 8; col++) {
        uint8_t vertical_byte = 0;
        for (int row = 0; row < 8; row++) {
            if (ch[row] & (1 << col)) {
                vertical_byte |= (1 << row);
            }
        }
        verticalChar[col] = vertical_byte;
    }
}

void reset_state(SSD1306_Handle_t *pSSD1306Handle) {
    pSSD1306Handle->DeviceState.PowerEnabled = DISABLE;
    pSSD1306Handle->DeviceState.Contrast = 0x7F;
    pSSD1306Handle->DeviceState.EntireDisplayON = DISABLE;
    pSSD1306Handle->DeviceState.ChargePumpEnabled = DISABLE;
    pSSD1306Handle->DeviceState.DisplayInversed = DISABLE;
    pSSD1306Handle->DeviceState.DisplayMode = SSD1306_DisplayModeSleep;

    pSSD1306Handle->DeviceState.ScrollState.Direction = SSD1306_HScrollRight;
    pSSD1306Handle->DeviceState.ScrollState.StartPageAddress = SSD1306_Page0;
    pSSD1306Handle->DeviceState.ScrollState.ScrollStepInterval = SSD1306_ScrollInterval5Frames;
    pSSD1306Handle->DeviceState.ScrollState.EndPageAddress = SSD1306_Page0;
    pSSD1306Handle->DeviceState.ScrollState.VerticalOffset = SSD1306_MIN_V_OFFSET;
    pSSD1306Handle->DeviceState.ScrollState.Enabled = DISABLE;
    pSSD1306Handle->DeviceState.ScrollState.StartRow = 0x00;
    pSSD1306Handle->DeviceState.ScrollState.NumberOfRows = 0x40;

    pSSD1306Handle->DeviceState.AddressingState.ColLowerNibble = SSD1306_MIN_PAGE_LWR_COL_ADDR;
    pSSD1306Handle->DeviceState.AddressingState.ColHigherNibble = SSD1306_MIN_PAGE_HIGH_COL_ADDR;
    pSSD1306Handle->DeviceState.AddressingState.AddressingMode = SSD1306_MemAddrPage;
    pSSD1306Handle->DeviceState.AddressingState.ColStartAddr = SSD1306_MIN_COL_ADDR;
    pSSD1306Handle->DeviceState.AddressingState.ColEndAddr = SSD1306_MAX_COL_ADDR;
    pSSD1306Handle->DeviceState.AddressingState.PageStartAddr = SSD1306_Page0;
    pSSD1306Handle->DeviceState.AddressingState.PageEndAddr = SSD1306_Page7;

    pSSD1306Handle->DeviceState.HardwareState.StartLine = SSD1306_DISPLAY_STRT_LINE_MIN;
    pSSD1306Handle->DeviceState.HardwareState.SegmentRemapped = DISABLE;
    pSSD1306Handle->DeviceState.HardwareState.MuxRatio = SSD1306_MAX_MUX_RATIO;
    pSSD1306Handle->DeviceState.HardwareState.COMScanRemapped = DISABLE;
    pSSD1306Handle->DeviceState.HardwareState.DisplayVOffset = SSD1306_MIN_V_OFFSET;
    pSSD1306Handle->DeviceState.HardwareState.AlternativeCOMPinConfig = ENABLE;
    pSSD1306Handle->DeviceState.HardwareState.COMLeftRightRemapEnabled = DISABLE;

    pSSD1306Handle->DeviceState.TimingState.DCLKDivRatio = SSD1306_MIN_DCLK_DIVIDE_RATIO;
    pSSD1306Handle->DeviceState.TimingState.OSCFreq = 0x08;
    pSSD1306Handle->DeviceState.TimingState.Phase1Period = 0x02;
    pSSD1306Handle->DeviceState.TimingState.Phase2Period = 0x02;
    pSSD1306Handle->DeviceState.TimingState.VCOMHDeselectLevel = SSD1306_VCOMHLevelMode1;
}
